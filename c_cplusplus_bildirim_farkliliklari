Bildirimlere İlişkin Farklılıklar
=================================

- C89'da fonksiyonların "implicit" bildirimi geçerli.
C99 standartları ile bu durum geçersiz hale getirildi.
C++'da implicit işlev bildirimi geçerli değil.

/*    örnek kod    */
void func()
{
    foo(); 
	//C89'da geçerli implicit olarak  
	//int foo();
	//bildirimi yapılmış kabul ediliyor
	//C99'da geçersiz C++'da geçersiz
}
--------------------------------------------------------------------------------------------------------------------------
- C89'da implicit int (gizli int - örtülü int - kapalı int) kuralı geçerli.
C99 standartları ile bu durum geçersiz kılındı.
C++'da "implicit int" geçerli değil.
C99/11 derleyicileri bir diagnostik vererek kodu derleyebilir. Derleyicinizin switch'lerini inceleyiniz.

/*    örnek kod    */
foo(); //C++'da geçersiz

func()  //C++'da geçersiz
{
	const x = 1;  //C++'da geçersiz
	static y = 2; //C++'da geçersiz
	///
	return 1;
}
--------------------------------------------------------------------------------------------------------------------------
C'de aşağıdaki iki bildirim arasında önemli bir fark var.
  void f1();      //f1 işlevinin parametre değişkenleri hakkında bir bilgi verilmiyor
  void f2(void);  //f2 işlevinin parametre değişkeni yok
C'de bu iki bildirimin arasındaki farklılık geçmişe doğru uyumluluğu koruma amaçlı
C++ dilinde bu iki bildirim eşdeğer.
--------------------------------------------------------------------------------------------------------------------------
C89'da for döngülerinin parantezi içindeki 1. kısımda bildirim yapılamıyor. C99 standartları böyle bildirimlere olanak sağlandı. 
C++ dilinde yapılabiliyor. Ancak burada bildirilen isimlerin scope'larına ilişkin C ile C++ arasında kural farklılığı var.

/*    örnek kod    */
#include <stdio.h>

int main()
{
	for (int i = 0; i < 10; ++i) {
		int i = 876; //c++'da geçersiz
		printf("%d ", i); //876
	}

	return 0;
}
--------------------------------------------------------------------------------------------------------------------------
Aşağıdaki bildirim C'de geçerli ve yazının sonunda null karakter yok.
char str[5] = "Samet"; 
Bu bildirim C++ dilinde geçersiz.
--------------------------------------------------------------------------------------------------------------------------
const nesne bildirimlerine ilişkin farklılıklar
- C'de const nesnelere ilk değer vermek zorunlu değil. C++ dilinde zorunlu.

- C'de sabit ifadeleri ile ilk değerini almış const nesneler sabit ifadesi gereken yerlerde kullanılamıyorlar.
C++'da kullanılabiliyorlar.

- C'de global const nesneler varsayılan biçimde dış bağlantıya (external linkage) aitler. 
C++'da iç bağlantıya (internal linkage) aitler.
--------------------------------------------------------------------------------------------------------------------------
C'de bir enum, union ve struct anahtar sözcükleri ile oluşturulan türler söz konusu olduğunda bildirimde kullanılan "tag" (etiket), 
değişken bildirimlerinde doğrudan kullanılamıyor:

/*    örnek kod    */
struct Point {
	int x, y;
};

union Data {
	char c1;
	char c2;
	int x;
}

enum Color {Red, Blue, Black};

Point p = {1, 3}; // C'de geçersiz C++'da geçerli
Color c = Black; // C'de geçersiz C++'da geçerli
Data data = {'A'}; // C'de geçersiz C++'da geçerli
--------------------------------------------------------------------------------------------------------------------------
Aşağıdaki bildirimler C'de geçerli C++'da geçersiz

int foo(int p[const]);     // int foo(const int *p) 
int bar(char s[static 5]); // uzunluğu en az 5 olan bir yazı adresi bekleniyor.
--------------------------------------------------------------------------------------------------------------------------

